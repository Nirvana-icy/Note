[iOS汇编入门-指令篇](https://juejin.cn/post/6961660156169945124)
[iOS开发同学的arm64汇编入门](https://juejin.cn/post/6844903713287454734)
[深入理解Macho文件（二）](https://satanwoo.github.io/2017/06/29/Macho-2/)

汇编里面要学习的三个重要概念， 寄存器、栈、指令。

### 一、汇编中指令和伪指令的区别？

1. 指令：机器码助记符，每条指令会生成机器码，由CPU读取执行。 

2. 伪指令（伪操作）：没有与之对应的机器码，非可执行指令，需要汇编器来解释。


### 寄存器

典型的CPU主要组成部分：运算器、控制器、寄存器。 

寄存器是CPU用来暂存指令、数据、地址的电脑存储器。它的存储容量有限，是CPU中最快的可读写存储器。

#### ARM64 寄存器

1. R0 - R30 

***r0 - r30*** 是31个通用整形寄存器。每个寄存器可以存取一个64位大小的数。 

当使用 x0 - x30访问时，它就是一个64位的数。当使用 w0 - w30访问时，访问的是这些寄存器的低32位。

其实通用寄存器有32个，第32个寄存器x31，在指令编码中，使用来做 zero register, 即ZR, XZR/WZR分别代表64/32位。

zero register的作用就是0，写进去代表丢弃结果，拿出来是0.

其中 r29 又被叫做 fp (frame pointer). 

r30 又被叫做 lr (link register)。其用途会在下一节《栈》中讲到。

2. SP

SP寄存器其实就是 x31，在指令编码中，使用 SP/WSP来进行对SP寄存器的访问。

3. PC

PC寄存器中存的是当前执行的指令的地址。在arm64中，软件是不能改写PC寄存器的。

4. SPRs

SPRs是状态寄存器，用于存放程序运行中一些状态标识。不同于编程语言里面的if else.在汇编中就需要根据状态寄存器中的一些状态来控制分支的执行。状态寄存器又分为 The Current Program Status Register (CPSR) 和 The Saved Program Status Registers (SPSRs)。 一般都是使用CPSR， 当发生异常时， CPSR会存入SPSR。当异常恢复，再拷贝回CPSR。

#### 通用寄存器中的参数 出于函数调用目的，通用寄存器被分为4组：

X0-X7：参数寄存器，用于将参数传递给函数并返回结果，返回值通过X0返回。
X9-X15：调用者保存的临时寄存器。
X19-X29：被调用者保存的寄存器。
X8,X16-X18,X29,X30：特殊用途的寄存器

在lldb中可以通过register read查看各寄存器状态

### 栈

栈就是指令执行时存放临时变量的内存空间。在学习汇编代码的执行过程中，了解栈的结构非常重要。

栈的特性：

1. 栈是从高地址到低地址的， 栈底是高地址，栈顶是低地址。

2. fp指向当前frame的栈底

3. sp指向栈顶


### 常见的计算指令

1. 移动指令：MOV，寄存器和寄存器之间传值

`mov    x2, x16             ;把x16的值传递给寄存器x2`

2. 算术运算指令： 加（ADD）、减（SUB)

`add x1, x2, x3             ;把x2+x3的值传递给寄存器x1`
`sub x1, x2, x3             ;把x2-x3的值传递给x1`

3. 逻辑运算指令：与（AND）、或（ORR）、异或（EOR）

`and    x1，x1，#0xf           ;把x1中的值与0xf按位与后传递给x1`
`orr    x1，x1，#6               ;把x1中的值与6按位与后传递给x1`
`eor    x1，x1，#0xf           ;把x1中的值与0xf按位异或后传递给x1`

4. 桶形移位器操作指令：LSL、LSR、ASR、ROR

`LSL：逻辑左移`
`LSR：逻辑右移`
`ASR：算术右移`
`ROR：循环右移`

5. 存/取数据指令：STR（寄存器加载到内存中）、取数据LDR （把内存中的数据传递给寄存器）

`str x1, [sp, #0x4]                  ;把x1寄存器的数据传递给sp+0x4地址值指向的内存空间`
`ldr x1, [sp, #0x4]                  ;把sp+0x4地址值内的数据传递给寄存器x1`

6. 栈操作指令：STP（入栈）、LDP（出栈）

`stp x0, x1,  [sp, #0x4]`
`ldp x0, x1,  [sp, #0x4]`

7. 比较指令：CMP，CBZ，CBNZ，TBZ，TBNZ

`cmp x0,x1                        ;把x0的内容和x1的内容进行比较，根据结果更新条件标志，并丢弃结果，相当于subs xzr x0, x1`

8. 跳转指令： B：无返回跳转，配合CMP使用 BL：带返回的跳转，会将返回地址存储到寄存器x30，说明这是一个子程序调用

```
示例1：
b    LLookupExample          ;直接跳转到LLookupExample

示例2：配合cmp使用
cmp x0,#6                    
b.eq LReturnZeroExample     ;如果x0等于6,则跳转LReturnZeroExample

条件代码：
b.eq                ;等于
b.ne                ;不等于
b.le                ;有符号的小于或等于
b.ge                ;有符号的大于或等于
b.lt                ;有符号小于
b.gt                ;有符号大于

示例3：
bl lookUpFindExample
```

9. 子程序返回指令：RET（返回地址存储在x30）

10. 寻址指令：ADRP（将PC相对地址形成4KB页面，即：取指定label的基地址，存储到指定寄存器中）

`adrp    x1, __example_handle@PAGE       ;获取__example_handle所在页的基地址存储到x1寄存器中`

11. 

